# 类的加载过程，双亲委派机制

## 加载过程

Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在[Java 虚拟机规范](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html)里有非常详细的定义

![类的声明周期](https://gitee.com/liuw5367/resource/raw/master/img/164586111676deba)

首先是**加载**阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。

第二阶段是**链接**（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：

- 验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。
- 准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。
- 解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。

最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。



## 双亲委派机制



![img](https://gitee.com/liuw5367/resource/raw/master/img/35a3bc241d779ddcc357639547917ca1.png)

**加载器的种类（从开发人员的角度）**

- 启动类加载器（Bootstrap ClassLoader）：负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中
- 扩展类加载器（Extension ClassLoader）：负责加载 <JAVA_HOME>\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库
- 应用程序类加载器（Application ClassLoader）：也称为系统类加载器，负责加载用户类路径（ClassPath）上所指定的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

**为什么要使用双亲委派模型**

借用一个例子：黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。

而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。

也就是说，无论那一个类加载器去加载一个系统中已有的类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此系统里在程序的各种类加载器环境中都是同一个类。

**双亲委派模型是如何实现的**

实现双亲委派的代码都几种在 java.lang.ClassLoader 的 loadClass() 方法中：先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。（看源码后发现这里的抛出异常是被吞了，catch 之后不会做任何操作）



### 自定义classLoader

```java
public class People {
  private String name;
}
// 编译成 People.class 放到其他目录
public static void main(String[] args) throws Exception {
    ALoader mcl = new ALoader();
    Class<?> clazz = Class.forName("People", true, mcl);
    Object obj = clazz.newInstance();

    System.out.println(obj);
    System.out.println(obj.getClass().getClassLoader());
}
// 如果People在项目中会使用 AppClassLoader。 输出为：
// I am a people, my name is null
// sun.misc.Launcher$AppClassLoader@18b4aac2

// 将People.class放到其他目录。 输出为：
// I am a people, my name is null
// test.ClassLoaderTest$ALoader@6e0be858

static class ALoader extends ClassLoader {
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        File file = new File("D:/People.class");
        try {
            byte[] bytes = getClassBytes(file);
            Class<?> c = this.defineClass(name, bytes, 0, bytes.length);
            return c;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return super.findClass(name);
    }

    private byte[] getClassBytes(File file) throws Exception {
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        WritableByteChannel wbc = Channels.newChannel(baos);
        ByteBuffer by = ByteBuffer.allocate(1024);

        while (true) {
            int i = fc.read(by);
            if (i == 0 || i == -1) break;
            by.flip();
            wbc.write(by);
            by.clear();
        }
        fis.close();
        return baos.toByteArray();
    }
}
```





[第23讲 | 请介绍类加载过程，什么是双亲委派模型？](https://time.geekbang.org/column/article/9946)

[JVM 类加载机制及双亲委派模型](https://juejin.cn/post/6844903630617706503)

[自定义类加载器](https://www.cnblogs.com/twoheads/p/10143038.html)